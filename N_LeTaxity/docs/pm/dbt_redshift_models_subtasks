# Re-create the plain-text WBS file so it's available to download
wbs_txt = """WBS â€” Redshift Serverless + dbt Best-Practice Setup (NYC Taxi)
=============================================================================
This work breakdown structure converts the Redshift best-practice blueprint into actionable tasks you can track. Check items off as you go.

Legend
------
- [x] = done, [ ] = todo
- XS / S / M / L = size estimate

=============================================================================
1) Environment & Security (Redshift Serverless)
Goal: Keep 'public' as immutable sources; add clean per-env, per-layer schemas for dbt output.

[ ] 1.1 Confirm environment details (XS)
    - Workgroup: teo-nyc-workgroup
    - Database: nyc_taxi_db
    - Source schema: public (tables: taxi_trip_data, taxi_zone_lookup)
    - Outcome: values recorded in README/notes.

[ ] 1.2 Create dbt-managed schemas (S)
    - DEV: dev_viper_stg, dev_viper_int, dev_viper_mart
    - PROD: prod_viper_stg, prod_viper_int, prod_viper_mart
    - SQL:
        create schema if not exists dev_viper_stg;
        create schema if not exists dev_viper_int;
        create schema if not exists dev_viper_mart;
        create schema if not exists prod_viper_stg;
        create schema if not exists prod_viper_int;
        create schema if not exists prod_viper_mart;
    - Outcome: schemas exist; visible in Redshift query editor.

[ ] 1.3 Grants & roles (S)
    - Create roles/groups for DEV writers and PROD readers (example):
        rs_transformer_dev -> USAGE, CREATE on dev_viper_*
        rs_reader_prod     -> USAGE on prod_viper_*, SELECT on prod_viper_mart
    - SQL (example):
        grant usage, create on schema dev_viper_stg  to rs_transformer_dev;
        grant usage, create on schema dev_viper_int  to rs_transformer_dev;
        grant usage, create on schema dev_viper_mart to rs_transformer_dev;

        grant usage on schema prod_viper_mart to rs_reader_prod;
        grant select on all tables in schema prod_viper_mart to rs_reader_prod;
        alter default privileges in schema prod_viper_mart grant select on tables to rs_reader_prod;
    - Outcome: role-based access enforced; no dev writes in prod.

[ ] 1.4 Secrets Manager -> env (S)
    - Store/confirm secret rs/nyc/dev with {username,password,host,database}.
    - Export helper (bash):
        SECRET_JSON=$(aws secretsmanager get-secret-value --secret-id rs/nyc/dev --query SecretString --output text)
        export REDSHIFT_USER_DEV=$(jq -r .username <<<"$SECRET_JSON")
        export REDSHIFT_PASSWORD_DEV=$(jq -r .password <<<"$SECRET_JSON")
        export REDSHIFT_HOST_DEV=$(jq -r .host <<<"$SECRET_JSON")
        export REDSHIFT_DB_DEV=$(jq -r .database <<<"$SECRET_JSON")
    - Outcome: 'dbt debug -t redshift_dev' succeeds.

=============================================================================
2) Local & Repo Prep
Goal: Ready the repo + venv for Redshift work.

[ ] 2.1 Create/activate feature branch (XS)
    cd /home/viperuser/projects/zen_clarity
    git checkout -b feat/redshift-dbt-model

[ ] 2.2 Ensure venv and adapters (XS)
    cd N_LeTaxity && source venv/bin/activate
    pip install -U dbt-redshift
    dbt --version

[ ] 2.3 Add Redshift outputs to ~/.dbt/profiles.yml (S)
    zen_clarity:
      target: dev
      outputs:
        redshift_dev:
          type: redshift
          host: "{{ env_var('REDSHIFT_HOST_DEV') }}"
          port: 5439
          user: "{{ env_var('REDSHIFT_USER_DEV') }}"
          password: "{{ env_var('REDSHIFT_PASSWORD_DEV') }}"
          dbname: "nyc_taxi_db"
          schema: "dev_viper"
          sslmode: require

        redshift_prod:
          type: redshift
          host: "{{ env_var('REDSHIFT_HOST_PROD') }}"
          port: 5439
          user: "{{ env_var('REDSHIFT_USER_PROD') }}"
          password: "{{ env_var('REDSHIFT_PASSWORD_PROD') }}"
          dbname: "nyc_taxi_db"
          schema: "prod_viper"
          sslmode: require
    Outcome: 'dbt debug -t redshift_dev' passes.

=============================================================================
3) Cross-DB Readiness (dbt config & macros)
Goal: One codebase runs on both Snowflake & Redshift.

[ ] 3.1 Schema-per-layer via macro (S)
    File: macros/generate_schema_name.sql
        {% macro generate_schema_name(custom_schema_name, node) -%}
          {% set base = target.schema %}
          {% if custom_schema_name is not none %}
            {{ base }}_{{ custom_schema_name | lower }}
          {% else %}
            {{ base }}
          {% endif %}
        {%- endmacro %}

    dbt_project.yml sections:
        models:
          N_LeTaxity:
            +materialized: view
            staging:
              +schema: stg
              +tags: ['staging']
            intermediate:
              +schema: int
              +tags: ['intermediate']
            marts:
              +schema: mart
              +tags: ['marts']

    Outcome: dev writes to dev_viper_stg/int/mart; prod to prod_viper_*.

[ ] 3.2 Date/time macro for DATEDIFF (XS)
    File: macros/date_utils.sql
        {% macro minutes_between(start_ts, end_ts) -%}
          {% if target.type == 'redshift' %}
            datediff(minute, {{ start_ts }}, {{ end_ts }})
          {% else %}
            datediff('minute', {{ start_ts }}, {{ end_ts }})
          {% endif %}
        {%- endmacro %}

    Update int_nyc__trip_zone.sql to use it:
        ..., {{ minutes_between("t.pickup_at","t.dropoff_at") }} as trip_duration_min

    Outcome: intermediate builds on both warehouses.

[ ] 3.3 Sources point to Redshift 'public' (S)
    File: models/staging/nyc_taxi/sources.yml
        version: 2
        sources:
          - name: nyc_taxi_db
            database: "nyc_taxi_db"
            schema: "public"
            tables:
              - name: taxi_trip_data
              - name: taxi_zone_lookup

    Outcome: staging reads from immutable sources.

=============================================================================
4) Build & Test (Redshift DEV)
Goal: Validate the full graph without touching 'public'.

[ ] 4.1 Parse & list (XS)
    dbt debug -t redshift_dev
    dbt parse -t redshift_dev
    dbt ls -t redshift_dev -s staging intermediate marts

[ ] 4.2 Build staging (S)
    dbt build -t redshift_dev -s tag:staging
    Acceptance: All staging tests pass.

[ ] 4.3 Build intermediate (S)
    dbt build -t redshift_dev -s int_nyc__trip_zone
    Acceptance: View (or table) created in dev_viper_int; tests pass.

[ ] 4.4 Build marts (6) (S/M)
    dbt build -t redshift_dev -s marts.nyc_taxi_dashboard
    Acceptance: All six marts created in dev_viper_mart; tests pass.

[ ] 4.5 Docs (optional) (XS)
    dbt docs generate -t redshift_dev
    dbt docs serve -t redshift_dev
    Acceptance: Lineage shows marts -> intermediate -> staging -> sources(public).

[ ] 4.6 Sanity QA (S)
    - Compare row counts/spot checks to Snowflake DEV for a small window.
    - Validate pickup_month and trip_duration_min logic.
    Outcome: functional equivalence accepted.

=============================================================================
5) Git & PR
Goal: Small, reviewable commits; PR to main.

[ ] 5.1 Commit in logical chunks (XS)
    git add N_LeTaxity/macros/*.sql
    git commit -m "feat(redshift): schema-per-layer + minutes_between macro"

    git add N_LeTaxity/models/staging/nyc_taxi/sources.yml
    git commit -m "chore(redshift): sources point to public.*"

    git add N_LeTaxity/models/**/*
    git commit -m "feat(marts): RS-compatible NYC dashboard marts"

[ ] 5.2 Push branch & open PR (XS)
    git push -u origin feat/redshift-dbt-model
    PR title suggestion:
      feat(redshift): add serverless targets, schema-per-layer, and RS-compatible models
    Acceptance: CI (if any) green; reviewer signs off.

=============================================================================
6) Promote to PROD (Redshift)
Goal: Same code, prod target & schemas.

[ ] 6.1 Ensure redshift_prod output (XS)
    - 'schema: prod_viper' in profiles; prod schemas exist & grants set.

[ ] 6.2 Build intermediate + dependents (S)
    dbt build -t redshift_prod -s int_nyc__trip_zone+
    Acceptance: Intermediate + downstream marts created in prod_viper_*.

[ ] 6.3 Build dashboard marts (S)
    dbt build -t redshift_prod -s marts.nyc_taxi_dashboard
    Acceptance: Tests pass; BI can read from prod_viper_mart.

[ ] 6.4 Communicate cutover (XS)
    - BI/consumers: read from prod_viper_mart going forward.
    - Keep legacy public.*_vw for a short overlap if needed; plan sunset.

=============================================================================
7) Optional: CI/CD for Redshift
Goal: Automate build/test on PR; deploy on main.

[ ] 7.1 GitHub Actions skeleton (S)
    - PR workflow: dbt build -t redshift_dev -s state:modified+
    - Main: dbt build -t redshift_prod -s int_nyc__trip_zone+ marts.nyc_taxi_dashboard
    Acceptance: Green checks required before merge.

=============================================================================
8) Optional: Performance & Materializations
Goal: Flip specific models to 'table' or 'incremental' if needed.

[ ] 8.1 Evaluate int_nyc__trip_zone (S)
    - If marts are heavy, set config(materialized='table') in prod only.
    - Consider sort key on pickup_month or pickup_datetime.
    Acceptance: Dashboard latency acceptable.

=============================================================================
Acceptance Criteria (project)
- 'dbt build' succeeds in dev and prod.
- Marts available in *_mart schemas; consumers read prod.
- Public tables remain unchanged; lineage clean.
- (Optional) CI enforces build/test on PRs.

Notes
- Use 'dbt build' rather than 'run' + 'test'.
- Prefer selectors: -s tag:staging, int_nyc__trip_zone+, marts.nyc_taxi_dashboard.
- If parser gets weird: dbt clean && dbt deps && dbt parse.
- Keep commits small; push early and PR often.
"""

file_path = "/mnt/data/WBS_Redshift_Serverless_dbt.txt"
with open(file_path, "w") as f:
    f.write(wbs_txt)

file_path
